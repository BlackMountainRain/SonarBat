// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sonar-bat/ent/dictionary"
	"sonar-bat/ent/host"
	"sonar-bat/ent/hostblacklist"
	"sonar-bat/ent/predicate"
	"sonar-bat/ent/rbacobject"
	"sonar-bat/ent/rbacpolicy"
	"sonar-bat/ent/rbacrole"
	"sonar-bat/ent/schema"
	"sonar-bat/ent/subtask"
	"sonar-bat/ent/task"
	"sonar-bat/ent/token"
	"sonar-bat/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDictionary    = "Dictionary"
	TypeHost          = "Host"
	TypeHostBlacklist = "HostBlacklist"
	TypeRbacObject    = "RbacObject"
	TypeRbacPolicy    = "RbacPolicy"
	TypeRbacRole      = "RbacRole"
	TypeSubtask       = "Subtask"
	TypeTask          = "Task"
	TypeToken         = "Token"
	TypeUser          = "User"
)

// DictionaryMutation represents an operation that mutates the Dictionary nodes in the graph.
type DictionaryMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	category      *string
	key           *string
	value         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Dictionary, error)
	predicates    []predicate.Dictionary
}

var _ ent.Mutation = (*DictionaryMutation)(nil)

// dictionaryOption allows management of the mutation configuration using functional options.
type dictionaryOption func(*DictionaryMutation)

// newDictionaryMutation creates new mutation for the Dictionary entity.
func newDictionaryMutation(c config, op Op, opts ...dictionaryOption) *DictionaryMutation {
	m := &DictionaryMutation{
		config:        c,
		op:            op,
		typ:           TypeDictionary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictionaryID sets the ID field of the mutation.
func withDictionaryID(id int64) dictionaryOption {
	return func(m *DictionaryMutation) {
		var (
			err   error
			once  sync.Once
			value *Dictionary
		)
		m.oldValue = func(ctx context.Context) (*Dictionary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dictionary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictionary sets the old Dictionary of the mutation.
func withDictionary(node *Dictionary) dictionaryOption {
	return func(m *DictionaryMutation) {
		m.oldValue = func(context.Context) (*Dictionary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictionaryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictionaryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dictionary entities.
func (m *DictionaryMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictionaryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictionaryMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dictionary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictionaryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictionaryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictionaryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictionaryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictionaryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictionaryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCategory sets the "category" field.
func (m *DictionaryMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *DictionaryMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *DictionaryMutation) ResetCategory() {
	m.category = nil
}

// SetKey sets the "key" field.
func (m *DictionaryMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *DictionaryMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *DictionaryMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *DictionaryMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *DictionaryMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *DictionaryMutation) ResetValue() {
	m.value = nil
}

// Where appends a list predicates to the DictionaryMutation builder.
func (m *DictionaryMutation) Where(ps ...predicate.Dictionary) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictionaryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictionaryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dictionary, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictionaryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictionaryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dictionary).
func (m *DictionaryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictionaryMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, dictionary.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictionary.FieldUpdatedAt)
	}
	if m.category != nil {
		fields = append(fields, dictionary.FieldCategory)
	}
	if m.key != nil {
		fields = append(fields, dictionary.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, dictionary.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictionaryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.CreatedAt()
	case dictionary.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictionary.FieldCategory:
		return m.Category()
	case dictionary.FieldKey:
		return m.Key()
	case dictionary.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictionaryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictionary.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictionary.FieldCategory:
		return m.OldCategory(ctx)
	case dictionary.FieldKey:
		return m.OldKey(ctx)
	case dictionary.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Dictionary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictionary.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictionary.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictionary.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case dictionary.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case dictionary.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictionaryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictionaryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Dictionary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictionaryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictionaryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictionaryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Dictionary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictionaryMutation) ResetField(name string) error {
	switch name {
	case dictionary.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictionary.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictionary.FieldCategory:
		m.ResetCategory()
		return nil
	case dictionary.FieldKey:
		m.ResetKey()
		return nil
	case dictionary.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Dictionary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictionaryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictionaryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictionaryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictionaryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictionaryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictionaryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictionaryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Dictionary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictionaryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Dictionary edge %s", name)
}

// HostMutation represents an operation that mutates the Host nodes in the graph.
type HostMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	status                *bool
	name                  *string
	live_at               *time.Time
	is_agent_installed    *bool
	agent_version         *string
	ips                   *[]schema.IpWithInfo
	appendips             []schema.IpWithInfo
	net_type              *int16
	addnet_type           *int16
	additions             *map[string]interface{}
	clearedFields         map[string]struct{}
	host_blacklist        map[uuid.UUID]struct{}
	removedhost_blacklist map[uuid.UUID]struct{}
	clearedhost_blacklist bool
	done                  bool
	oldValue              func(context.Context) (*Host, error)
	predicates            []predicate.Host
}

var _ ent.Mutation = (*HostMutation)(nil)

// hostOption allows management of the mutation configuration using functional options.
type hostOption func(*HostMutation)

// newHostMutation creates new mutation for the Host entity.
func newHostMutation(c config, op Op, opts ...hostOption) *HostMutation {
	m := &HostMutation{
		config:        c,
		op:            op,
		typ:           TypeHost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostID sets the ID field of the mutation.
func withHostID(id uuid.UUID) hostOption {
	return func(m *HostMutation) {
		var (
			err   error
			once  sync.Once
			value *Host
		)
		m.oldValue = func(ctx context.Context) (*Host, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Host.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHost sets the old Host of the mutation.
func withHost(node *Host) hostOption {
	return func(m *HostMutation) {
		m.oldValue = func(context.Context) (*Host, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Host entities.
func (m *HostMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HostMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HostMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Host.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HostMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *HostMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *HostMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *HostMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *HostMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HostMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HostMutation) ResetName() {
	m.name = nil
}

// SetLiveAt sets the "live_at" field.
func (m *HostMutation) SetLiveAt(t time.Time) {
	m.live_at = &t
}

// LiveAt returns the value of the "live_at" field in the mutation.
func (m *HostMutation) LiveAt() (r time.Time, exists bool) {
	v := m.live_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLiveAt returns the old "live_at" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldLiveAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLiveAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLiveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLiveAt: %w", err)
	}
	return oldValue.LiveAt, nil
}

// ClearLiveAt clears the value of the "live_at" field.
func (m *HostMutation) ClearLiveAt() {
	m.live_at = nil
	m.clearedFields[host.FieldLiveAt] = struct{}{}
}

// LiveAtCleared returns if the "live_at" field was cleared in this mutation.
func (m *HostMutation) LiveAtCleared() bool {
	_, ok := m.clearedFields[host.FieldLiveAt]
	return ok
}

// ResetLiveAt resets all changes to the "live_at" field.
func (m *HostMutation) ResetLiveAt() {
	m.live_at = nil
	delete(m.clearedFields, host.FieldLiveAt)
}

// SetIsAgentInstalled sets the "is_agent_installed" field.
func (m *HostMutation) SetIsAgentInstalled(b bool) {
	m.is_agent_installed = &b
}

// IsAgentInstalled returns the value of the "is_agent_installed" field in the mutation.
func (m *HostMutation) IsAgentInstalled() (r bool, exists bool) {
	v := m.is_agent_installed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAgentInstalled returns the old "is_agent_installed" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldIsAgentInstalled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAgentInstalled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAgentInstalled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAgentInstalled: %w", err)
	}
	return oldValue.IsAgentInstalled, nil
}

// ResetIsAgentInstalled resets all changes to the "is_agent_installed" field.
func (m *HostMutation) ResetIsAgentInstalled() {
	m.is_agent_installed = nil
}

// SetAgentVersion sets the "agent_version" field.
func (m *HostMutation) SetAgentVersion(s string) {
	m.agent_version = &s
}

// AgentVersion returns the value of the "agent_version" field in the mutation.
func (m *HostMutation) AgentVersion() (r string, exists bool) {
	v := m.agent_version
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentVersion returns the old "agent_version" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldAgentVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentVersion: %w", err)
	}
	return oldValue.AgentVersion, nil
}

// ClearAgentVersion clears the value of the "agent_version" field.
func (m *HostMutation) ClearAgentVersion() {
	m.agent_version = nil
	m.clearedFields[host.FieldAgentVersion] = struct{}{}
}

// AgentVersionCleared returns if the "agent_version" field was cleared in this mutation.
func (m *HostMutation) AgentVersionCleared() bool {
	_, ok := m.clearedFields[host.FieldAgentVersion]
	return ok
}

// ResetAgentVersion resets all changes to the "agent_version" field.
func (m *HostMutation) ResetAgentVersion() {
	m.agent_version = nil
	delete(m.clearedFields, host.FieldAgentVersion)
}

// SetIps sets the "ips" field.
func (m *HostMutation) SetIps(swi []schema.IpWithInfo) {
	m.ips = &swi
	m.appendips = nil
}

// Ips returns the value of the "ips" field in the mutation.
func (m *HostMutation) Ips() (r []schema.IpWithInfo, exists bool) {
	v := m.ips
	if v == nil {
		return
	}
	return *v, true
}

// OldIps returns the old "ips" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldIps(ctx context.Context) (v []schema.IpWithInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIps: %w", err)
	}
	return oldValue.Ips, nil
}

// AppendIps adds swi to the "ips" field.
func (m *HostMutation) AppendIps(swi []schema.IpWithInfo) {
	m.appendips = append(m.appendips, swi...)
}

// AppendedIps returns the list of values that were appended to the "ips" field in this mutation.
func (m *HostMutation) AppendedIps() ([]schema.IpWithInfo, bool) {
	if len(m.appendips) == 0 {
		return nil, false
	}
	return m.appendips, true
}

// ClearIps clears the value of the "ips" field.
func (m *HostMutation) ClearIps() {
	m.ips = nil
	m.appendips = nil
	m.clearedFields[host.FieldIps] = struct{}{}
}

// IpsCleared returns if the "ips" field was cleared in this mutation.
func (m *HostMutation) IpsCleared() bool {
	_, ok := m.clearedFields[host.FieldIps]
	return ok
}

// ResetIps resets all changes to the "ips" field.
func (m *HostMutation) ResetIps() {
	m.ips = nil
	m.appendips = nil
	delete(m.clearedFields, host.FieldIps)
}

// SetNetType sets the "net_type" field.
func (m *HostMutation) SetNetType(i int16) {
	m.net_type = &i
	m.addnet_type = nil
}

// NetType returns the value of the "net_type" field in the mutation.
func (m *HostMutation) NetType() (r int16, exists bool) {
	v := m.net_type
	if v == nil {
		return
	}
	return *v, true
}

// OldNetType returns the old "net_type" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldNetType(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetType: %w", err)
	}
	return oldValue.NetType, nil
}

// AddNetType adds i to the "net_type" field.
func (m *HostMutation) AddNetType(i int16) {
	if m.addnet_type != nil {
		*m.addnet_type += i
	} else {
		m.addnet_type = &i
	}
}

// AddedNetType returns the value that was added to the "net_type" field in this mutation.
func (m *HostMutation) AddedNetType() (r int16, exists bool) {
	v := m.addnet_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearNetType clears the value of the "net_type" field.
func (m *HostMutation) ClearNetType() {
	m.net_type = nil
	m.addnet_type = nil
	m.clearedFields[host.FieldNetType] = struct{}{}
}

// NetTypeCleared returns if the "net_type" field was cleared in this mutation.
func (m *HostMutation) NetTypeCleared() bool {
	_, ok := m.clearedFields[host.FieldNetType]
	return ok
}

// ResetNetType resets all changes to the "net_type" field.
func (m *HostMutation) ResetNetType() {
	m.net_type = nil
	m.addnet_type = nil
	delete(m.clearedFields, host.FieldNetType)
}

// SetAdditions sets the "additions" field.
func (m *HostMutation) SetAdditions(value map[string]interface{}) {
	m.additions = &value
}

// Additions returns the value of the "additions" field in the mutation.
func (m *HostMutation) Additions() (r map[string]interface{}, exists bool) {
	v := m.additions
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditions returns the old "additions" field's value of the Host entity.
// If the Host object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostMutation) OldAdditions(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditions: %w", err)
	}
	return oldValue.Additions, nil
}

// ClearAdditions clears the value of the "additions" field.
func (m *HostMutation) ClearAdditions() {
	m.additions = nil
	m.clearedFields[host.FieldAdditions] = struct{}{}
}

// AdditionsCleared returns if the "additions" field was cleared in this mutation.
func (m *HostMutation) AdditionsCleared() bool {
	_, ok := m.clearedFields[host.FieldAdditions]
	return ok
}

// ResetAdditions resets all changes to the "additions" field.
func (m *HostMutation) ResetAdditions() {
	m.additions = nil
	delete(m.clearedFields, host.FieldAdditions)
}

// AddHostBlacklistIDs adds the "host_blacklist" edge to the HostBlacklist entity by ids.
func (m *HostMutation) AddHostBlacklistIDs(ids ...uuid.UUID) {
	if m.host_blacklist == nil {
		m.host_blacklist = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.host_blacklist[ids[i]] = struct{}{}
	}
}

// ClearHostBlacklist clears the "host_blacklist" edge to the HostBlacklist entity.
func (m *HostMutation) ClearHostBlacklist() {
	m.clearedhost_blacklist = true
}

// HostBlacklistCleared reports if the "host_blacklist" edge to the HostBlacklist entity was cleared.
func (m *HostMutation) HostBlacklistCleared() bool {
	return m.clearedhost_blacklist
}

// RemoveHostBlacklistIDs removes the "host_blacklist" edge to the HostBlacklist entity by IDs.
func (m *HostMutation) RemoveHostBlacklistIDs(ids ...uuid.UUID) {
	if m.removedhost_blacklist == nil {
		m.removedhost_blacklist = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.host_blacklist, ids[i])
		m.removedhost_blacklist[ids[i]] = struct{}{}
	}
}

// RemovedHostBlacklist returns the removed IDs of the "host_blacklist" edge to the HostBlacklist entity.
func (m *HostMutation) RemovedHostBlacklistIDs() (ids []uuid.UUID) {
	for id := range m.removedhost_blacklist {
		ids = append(ids, id)
	}
	return
}

// HostBlacklistIDs returns the "host_blacklist" edge IDs in the mutation.
func (m *HostMutation) HostBlacklistIDs() (ids []uuid.UUID) {
	for id := range m.host_blacklist {
		ids = append(ids, id)
	}
	return
}

// ResetHostBlacklist resets all changes to the "host_blacklist" edge.
func (m *HostMutation) ResetHostBlacklist() {
	m.host_blacklist = nil
	m.clearedhost_blacklist = false
	m.removedhost_blacklist = nil
}

// Where appends a list predicates to the HostMutation builder.
func (m *HostMutation) Where(ps ...predicate.Host) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Host, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Host).
func (m *HostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, host.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, host.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, host.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, host.FieldName)
	}
	if m.live_at != nil {
		fields = append(fields, host.FieldLiveAt)
	}
	if m.is_agent_installed != nil {
		fields = append(fields, host.FieldIsAgentInstalled)
	}
	if m.agent_version != nil {
		fields = append(fields, host.FieldAgentVersion)
	}
	if m.ips != nil {
		fields = append(fields, host.FieldIps)
	}
	if m.net_type != nil {
		fields = append(fields, host.FieldNetType)
	}
	if m.additions != nil {
		fields = append(fields, host.FieldAdditions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case host.FieldCreatedAt:
		return m.CreatedAt()
	case host.FieldUpdatedAt:
		return m.UpdatedAt()
	case host.FieldStatus:
		return m.Status()
	case host.FieldName:
		return m.Name()
	case host.FieldLiveAt:
		return m.LiveAt()
	case host.FieldIsAgentInstalled:
		return m.IsAgentInstalled()
	case host.FieldAgentVersion:
		return m.AgentVersion()
	case host.FieldIps:
		return m.Ips()
	case host.FieldNetType:
		return m.NetType()
	case host.FieldAdditions:
		return m.Additions()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case host.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case host.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case host.FieldStatus:
		return m.OldStatus(ctx)
	case host.FieldName:
		return m.OldName(ctx)
	case host.FieldLiveAt:
		return m.OldLiveAt(ctx)
	case host.FieldIsAgentInstalled:
		return m.OldIsAgentInstalled(ctx)
	case host.FieldAgentVersion:
		return m.OldAgentVersion(ctx)
	case host.FieldIps:
		return m.OldIps(ctx)
	case host.FieldNetType:
		return m.OldNetType(ctx)
	case host.FieldAdditions:
		return m.OldAdditions(ctx)
	}
	return nil, fmt.Errorf("unknown Host field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case host.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case host.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case host.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case host.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case host.FieldLiveAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLiveAt(v)
		return nil
	case host.FieldIsAgentInstalled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAgentInstalled(v)
		return nil
	case host.FieldAgentVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentVersion(v)
		return nil
	case host.FieldIps:
		v, ok := value.([]schema.IpWithInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIps(v)
		return nil
	case host.FieldNetType:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetType(v)
		return nil
	case host.FieldAdditions:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditions(v)
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostMutation) AddedFields() []string {
	var fields []string
	if m.addnet_type != nil {
		fields = append(fields, host.FieldNetType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case host.FieldNetType:
		return m.AddedNetType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case host.FieldNetType:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNetType(v)
		return nil
	}
	return fmt.Errorf("unknown Host numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(host.FieldLiveAt) {
		fields = append(fields, host.FieldLiveAt)
	}
	if m.FieldCleared(host.FieldAgentVersion) {
		fields = append(fields, host.FieldAgentVersion)
	}
	if m.FieldCleared(host.FieldIps) {
		fields = append(fields, host.FieldIps)
	}
	if m.FieldCleared(host.FieldNetType) {
		fields = append(fields, host.FieldNetType)
	}
	if m.FieldCleared(host.FieldAdditions) {
		fields = append(fields, host.FieldAdditions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostMutation) ClearField(name string) error {
	switch name {
	case host.FieldLiveAt:
		m.ClearLiveAt()
		return nil
	case host.FieldAgentVersion:
		m.ClearAgentVersion()
		return nil
	case host.FieldIps:
		m.ClearIps()
		return nil
	case host.FieldNetType:
		m.ClearNetType()
		return nil
	case host.FieldAdditions:
		m.ClearAdditions()
		return nil
	}
	return fmt.Errorf("unknown Host nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostMutation) ResetField(name string) error {
	switch name {
	case host.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case host.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case host.FieldStatus:
		m.ResetStatus()
		return nil
	case host.FieldName:
		m.ResetName()
		return nil
	case host.FieldLiveAt:
		m.ResetLiveAt()
		return nil
	case host.FieldIsAgentInstalled:
		m.ResetIsAgentInstalled()
		return nil
	case host.FieldAgentVersion:
		m.ResetAgentVersion()
		return nil
	case host.FieldIps:
		m.ResetIps()
		return nil
	case host.FieldNetType:
		m.ResetNetType()
		return nil
	case host.FieldAdditions:
		m.ResetAdditions()
		return nil
	}
	return fmt.Errorf("unknown Host field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.host_blacklist != nil {
		edges = append(edges, host.EdgeHostBlacklist)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeHostBlacklist:
		ids := make([]ent.Value, 0, len(m.host_blacklist))
		for id := range m.host_blacklist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedhost_blacklist != nil {
		edges = append(edges, host.EdgeHostBlacklist)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case host.EdgeHostBlacklist:
		ids := make([]ent.Value, 0, len(m.removedhost_blacklist))
		for id := range m.removedhost_blacklist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhost_blacklist {
		edges = append(edges, host.EdgeHostBlacklist)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostMutation) EdgeCleared(name string) bool {
	switch name {
	case host.EdgeHostBlacklist:
		return m.clearedhost_blacklist
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Host unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostMutation) ResetEdge(name string) error {
	switch name {
	case host.EdgeHostBlacklist:
		m.ResetHostBlacklist()
		return nil
	}
	return fmt.Errorf("unknown Host edge %s", name)
}

// HostBlacklistMutation represents an operation that mutates the HostBlacklist nodes in the graph.
type HostBlacklistMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	updated_by    *uuid.UUID
	created_by    *uuid.UUID
	reason        *string
	clearedFields map[string]struct{}
	host          *uuid.UUID
	clearedhost   bool
	done          bool
	oldValue      func(context.Context) (*HostBlacklist, error)
	predicates    []predicate.HostBlacklist
}

var _ ent.Mutation = (*HostBlacklistMutation)(nil)

// hostblacklistOption allows management of the mutation configuration using functional options.
type hostblacklistOption func(*HostBlacklistMutation)

// newHostBlacklistMutation creates new mutation for the HostBlacklist entity.
func newHostBlacklistMutation(c config, op Op, opts ...hostblacklistOption) *HostBlacklistMutation {
	m := &HostBlacklistMutation{
		config:        c,
		op:            op,
		typ:           TypeHostBlacklist,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHostBlacklistID sets the ID field of the mutation.
func withHostBlacklistID(id uuid.UUID) hostblacklistOption {
	return func(m *HostBlacklistMutation) {
		var (
			err   error
			once  sync.Once
			value *HostBlacklist
		)
		m.oldValue = func(ctx context.Context) (*HostBlacklist, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HostBlacklist.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHostBlacklist sets the old HostBlacklist of the mutation.
func withHostBlacklist(node *HostBlacklist) hostblacklistOption {
	return func(m *HostBlacklistMutation) {
		m.oldValue = func(context.Context) (*HostBlacklist, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HostBlacklistMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HostBlacklistMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HostBlacklist entities.
func (m *HostBlacklistMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HostBlacklistMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HostBlacklistMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HostBlacklist.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HostBlacklistMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HostBlacklistMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HostBlacklist entity.
// If the HostBlacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostBlacklistMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HostBlacklistMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HostBlacklistMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HostBlacklistMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HostBlacklist entity.
// If the HostBlacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostBlacklistMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HostBlacklistMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *HostBlacklistMutation) SetUpdatedBy(u uuid.UUID) {
	m.updated_by = &u
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *HostBlacklistMutation) UpdatedBy() (r uuid.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the HostBlacklist entity.
// If the HostBlacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostBlacklistMutation) OldUpdatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *HostBlacklistMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *HostBlacklistMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *HostBlacklistMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the HostBlacklist entity.
// If the HostBlacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostBlacklistMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *HostBlacklistMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetHostID sets the "host_id" field.
func (m *HostBlacklistMutation) SetHostID(u uuid.UUID) {
	m.host = &u
}

// HostID returns the value of the "host_id" field in the mutation.
func (m *HostBlacklistMutation) HostID() (r uuid.UUID, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHostID returns the old "host_id" field's value of the HostBlacklist entity.
// If the HostBlacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostBlacklistMutation) OldHostID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHostID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHostID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHostID: %w", err)
	}
	return oldValue.HostID, nil
}

// ResetHostID resets all changes to the "host_id" field.
func (m *HostBlacklistMutation) ResetHostID() {
	m.host = nil
}

// SetReason sets the "reason" field.
func (m *HostBlacklistMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *HostBlacklistMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the HostBlacklist entity.
// If the HostBlacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HostBlacklistMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *HostBlacklistMutation) ResetReason() {
	m.reason = nil
}

// ClearHost clears the "host" edge to the Host entity.
func (m *HostBlacklistMutation) ClearHost() {
	m.clearedhost = true
	m.clearedFields[hostblacklist.FieldHostID] = struct{}{}
}

// HostCleared reports if the "host" edge to the Host entity was cleared.
func (m *HostBlacklistMutation) HostCleared() bool {
	return m.clearedhost
}

// HostIDs returns the "host" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HostID instead. It exists only for internal usage by the builders.
func (m *HostBlacklistMutation) HostIDs() (ids []uuid.UUID) {
	if id := m.host; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHost resets all changes to the "host" edge.
func (m *HostBlacklistMutation) ResetHost() {
	m.host = nil
	m.clearedhost = false
}

// Where appends a list predicates to the HostBlacklistMutation builder.
func (m *HostBlacklistMutation) Where(ps ...predicate.HostBlacklist) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HostBlacklistMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HostBlacklistMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HostBlacklist, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HostBlacklistMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HostBlacklistMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HostBlacklist).
func (m *HostBlacklistMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HostBlacklistMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, hostblacklist.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hostblacklist.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, hostblacklist.FieldUpdatedBy)
	}
	if m.created_by != nil {
		fields = append(fields, hostblacklist.FieldCreatedBy)
	}
	if m.host != nil {
		fields = append(fields, hostblacklist.FieldHostID)
	}
	if m.reason != nil {
		fields = append(fields, hostblacklist.FieldReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HostBlacklistMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hostblacklist.FieldCreatedAt:
		return m.CreatedAt()
	case hostblacklist.FieldUpdatedAt:
		return m.UpdatedAt()
	case hostblacklist.FieldUpdatedBy:
		return m.UpdatedBy()
	case hostblacklist.FieldCreatedBy:
		return m.CreatedBy()
	case hostblacklist.FieldHostID:
		return m.HostID()
	case hostblacklist.FieldReason:
		return m.Reason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HostBlacklistMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hostblacklist.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hostblacklist.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hostblacklist.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case hostblacklist.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case hostblacklist.FieldHostID:
		return m.OldHostID(ctx)
	case hostblacklist.FieldReason:
		return m.OldReason(ctx)
	}
	return nil, fmt.Errorf("unknown HostBlacklist field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostBlacklistMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hostblacklist.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hostblacklist.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hostblacklist.FieldUpdatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case hostblacklist.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case hostblacklist.FieldHostID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHostID(v)
		return nil
	case hostblacklist.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	}
	return fmt.Errorf("unknown HostBlacklist field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HostBlacklistMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HostBlacklistMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HostBlacklistMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HostBlacklist numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HostBlacklistMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HostBlacklistMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HostBlacklistMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HostBlacklist nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HostBlacklistMutation) ResetField(name string) error {
	switch name {
	case hostblacklist.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hostblacklist.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hostblacklist.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case hostblacklist.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case hostblacklist.FieldHostID:
		m.ResetHostID()
		return nil
	case hostblacklist.FieldReason:
		m.ResetReason()
		return nil
	}
	return fmt.Errorf("unknown HostBlacklist field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HostBlacklistMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.host != nil {
		edges = append(edges, hostblacklist.EdgeHost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HostBlacklistMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hostblacklist.EdgeHost:
		if id := m.host; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HostBlacklistMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HostBlacklistMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HostBlacklistMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhost {
		edges = append(edges, hostblacklist.EdgeHost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HostBlacklistMutation) EdgeCleared(name string) bool {
	switch name {
	case hostblacklist.EdgeHost:
		return m.clearedhost
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HostBlacklistMutation) ClearEdge(name string) error {
	switch name {
	case hostblacklist.EdgeHost:
		m.ClearHost()
		return nil
	}
	return fmt.Errorf("unknown HostBlacklist unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HostBlacklistMutation) ResetEdge(name string) error {
	switch name {
	case hostblacklist.EdgeHost:
		m.ResetHost()
		return nil
	}
	return fmt.Errorf("unknown HostBlacklist edge %s", name)
}

// RbacObjectMutation represents an operation that mutates the RbacObject nodes in the graph.
type RbacObjectMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	updated_by    *uuid.UUID
	created_by    *uuid.UUID
	status        *bool
	value         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*RbacObject, error)
	predicates    []predicate.RbacObject
}

var _ ent.Mutation = (*RbacObjectMutation)(nil)

// rbacobjectOption allows management of the mutation configuration using functional options.
type rbacobjectOption func(*RbacObjectMutation)

// newRbacObjectMutation creates new mutation for the RbacObject entity.
func newRbacObjectMutation(c config, op Op, opts ...rbacobjectOption) *RbacObjectMutation {
	m := &RbacObjectMutation{
		config:        c,
		op:            op,
		typ:           TypeRbacObject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRbacObjectID sets the ID field of the mutation.
func withRbacObjectID(id int64) rbacobjectOption {
	return func(m *RbacObjectMutation) {
		var (
			err   error
			once  sync.Once
			value *RbacObject
		)
		m.oldValue = func(ctx context.Context) (*RbacObject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RbacObject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRbacObject sets the old RbacObject of the mutation.
func withRbacObject(node *RbacObject) rbacobjectOption {
	return func(m *RbacObjectMutation) {
		m.oldValue = func(context.Context) (*RbacObject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RbacObjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RbacObjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RbacObject entities.
func (m *RbacObjectMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RbacObjectMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RbacObjectMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RbacObject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RbacObjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RbacObjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RbacObject entity.
// If the RbacObject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacObjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RbacObjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RbacObjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RbacObjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RbacObject entity.
// If the RbacObject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacObjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RbacObjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RbacObjectMutation) SetUpdatedBy(u uuid.UUID) {
	m.updated_by = &u
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RbacObjectMutation) UpdatedBy() (r uuid.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RbacObject entity.
// If the RbacObject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacObjectMutation) OldUpdatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RbacObjectMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RbacObjectMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RbacObjectMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RbacObject entity.
// If the RbacObject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacObjectMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RbacObjectMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetStatus sets the "status" field.
func (m *RbacObjectMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *RbacObjectMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RbacObject entity.
// If the RbacObject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacObjectMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RbacObjectMutation) ResetStatus() {
	m.status = nil
}

// SetValue sets the "value" field.
func (m *RbacObjectMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *RbacObjectMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the RbacObject entity.
// If the RbacObject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacObjectMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *RbacObjectMutation) ResetValue() {
	m.value = nil
}

// Where appends a list predicates to the RbacObjectMutation builder.
func (m *RbacObjectMutation) Where(ps ...predicate.RbacObject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RbacObjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RbacObjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RbacObject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RbacObjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RbacObjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RbacObject).
func (m *RbacObjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RbacObjectMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, rbacobject.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rbacobject.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, rbacobject.FieldUpdatedBy)
	}
	if m.created_by != nil {
		fields = append(fields, rbacobject.FieldCreatedBy)
	}
	if m.status != nil {
		fields = append(fields, rbacobject.FieldStatus)
	}
	if m.value != nil {
		fields = append(fields, rbacobject.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RbacObjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rbacobject.FieldCreatedAt:
		return m.CreatedAt()
	case rbacobject.FieldUpdatedAt:
		return m.UpdatedAt()
	case rbacobject.FieldUpdatedBy:
		return m.UpdatedBy()
	case rbacobject.FieldCreatedBy:
		return m.CreatedBy()
	case rbacobject.FieldStatus:
		return m.Status()
	case rbacobject.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RbacObjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rbacobject.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rbacobject.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rbacobject.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case rbacobject.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case rbacobject.FieldStatus:
		return m.OldStatus(ctx)
	case rbacobject.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown RbacObject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RbacObjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rbacobject.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rbacobject.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rbacobject.FieldUpdatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case rbacobject.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case rbacobject.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case rbacobject.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown RbacObject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RbacObjectMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RbacObjectMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RbacObjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RbacObject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RbacObjectMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RbacObjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RbacObjectMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RbacObject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RbacObjectMutation) ResetField(name string) error {
	switch name {
	case rbacobject.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rbacobject.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rbacobject.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case rbacobject.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case rbacobject.FieldStatus:
		m.ResetStatus()
		return nil
	case rbacobject.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown RbacObject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RbacObjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RbacObjectMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RbacObjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RbacObjectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RbacObjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RbacObjectMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RbacObjectMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RbacObject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RbacObjectMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RbacObject edge %s", name)
}

// RbacPolicyMutation represents an operation that mutates the RbacPolicy nodes in the graph.
type RbacPolicyMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	updated_by    *uuid.UUID
	created_by    *uuid.UUID
	role          *string
	obj           *string
	act           *string
	uri           *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*RbacPolicy, error)
	predicates    []predicate.RbacPolicy
}

var _ ent.Mutation = (*RbacPolicyMutation)(nil)

// rbacpolicyOption allows management of the mutation configuration using functional options.
type rbacpolicyOption func(*RbacPolicyMutation)

// newRbacPolicyMutation creates new mutation for the RbacPolicy entity.
func newRbacPolicyMutation(c config, op Op, opts ...rbacpolicyOption) *RbacPolicyMutation {
	m := &RbacPolicyMutation{
		config:        c,
		op:            op,
		typ:           TypeRbacPolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRbacPolicyID sets the ID field of the mutation.
func withRbacPolicyID(id int64) rbacpolicyOption {
	return func(m *RbacPolicyMutation) {
		var (
			err   error
			once  sync.Once
			value *RbacPolicy
		)
		m.oldValue = func(ctx context.Context) (*RbacPolicy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RbacPolicy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRbacPolicy sets the old RbacPolicy of the mutation.
func withRbacPolicy(node *RbacPolicy) rbacpolicyOption {
	return func(m *RbacPolicyMutation) {
		m.oldValue = func(context.Context) (*RbacPolicy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RbacPolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RbacPolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RbacPolicy entities.
func (m *RbacPolicyMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RbacPolicyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RbacPolicyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RbacPolicy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RbacPolicyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RbacPolicyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RbacPolicy entity.
// If the RbacPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacPolicyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RbacPolicyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RbacPolicyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RbacPolicyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RbacPolicy entity.
// If the RbacPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacPolicyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RbacPolicyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RbacPolicyMutation) SetUpdatedBy(u uuid.UUID) {
	m.updated_by = &u
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RbacPolicyMutation) UpdatedBy() (r uuid.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RbacPolicy entity.
// If the RbacPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacPolicyMutation) OldUpdatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RbacPolicyMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RbacPolicyMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RbacPolicyMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RbacPolicy entity.
// If the RbacPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacPolicyMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RbacPolicyMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetRole sets the "role" field.
func (m *RbacPolicyMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *RbacPolicyMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the RbacPolicy entity.
// If the RbacPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacPolicyMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ClearRole clears the value of the "role" field.
func (m *RbacPolicyMutation) ClearRole() {
	m.role = nil
	m.clearedFields[rbacpolicy.FieldRole] = struct{}{}
}

// RoleCleared returns if the "role" field was cleared in this mutation.
func (m *RbacPolicyMutation) RoleCleared() bool {
	_, ok := m.clearedFields[rbacpolicy.FieldRole]
	return ok
}

// ResetRole resets all changes to the "role" field.
func (m *RbacPolicyMutation) ResetRole() {
	m.role = nil
	delete(m.clearedFields, rbacpolicy.FieldRole)
}

// SetObj sets the "obj" field.
func (m *RbacPolicyMutation) SetObj(s string) {
	m.obj = &s
}

// Obj returns the value of the "obj" field in the mutation.
func (m *RbacPolicyMutation) Obj() (r string, exists bool) {
	v := m.obj
	if v == nil {
		return
	}
	return *v, true
}

// OldObj returns the old "obj" field's value of the RbacPolicy entity.
// If the RbacPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacPolicyMutation) OldObj(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObj is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObj requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObj: %w", err)
	}
	return oldValue.Obj, nil
}

// ClearObj clears the value of the "obj" field.
func (m *RbacPolicyMutation) ClearObj() {
	m.obj = nil
	m.clearedFields[rbacpolicy.FieldObj] = struct{}{}
}

// ObjCleared returns if the "obj" field was cleared in this mutation.
func (m *RbacPolicyMutation) ObjCleared() bool {
	_, ok := m.clearedFields[rbacpolicy.FieldObj]
	return ok
}

// ResetObj resets all changes to the "obj" field.
func (m *RbacPolicyMutation) ResetObj() {
	m.obj = nil
	delete(m.clearedFields, rbacpolicy.FieldObj)
}

// SetAct sets the "act" field.
func (m *RbacPolicyMutation) SetAct(s string) {
	m.act = &s
}

// Act returns the value of the "act" field in the mutation.
func (m *RbacPolicyMutation) Act() (r string, exists bool) {
	v := m.act
	if v == nil {
		return
	}
	return *v, true
}

// OldAct returns the old "act" field's value of the RbacPolicy entity.
// If the RbacPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacPolicyMutation) OldAct(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAct is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAct requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAct: %w", err)
	}
	return oldValue.Act, nil
}

// ClearAct clears the value of the "act" field.
func (m *RbacPolicyMutation) ClearAct() {
	m.act = nil
	m.clearedFields[rbacpolicy.FieldAct] = struct{}{}
}

// ActCleared returns if the "act" field was cleared in this mutation.
func (m *RbacPolicyMutation) ActCleared() bool {
	_, ok := m.clearedFields[rbacpolicy.FieldAct]
	return ok
}

// ResetAct resets all changes to the "act" field.
func (m *RbacPolicyMutation) ResetAct() {
	m.act = nil
	delete(m.clearedFields, rbacpolicy.FieldAct)
}

// SetURI sets the "uri" field.
func (m *RbacPolicyMutation) SetURI(s string) {
	m.uri = &s
}

// URI returns the value of the "uri" field in the mutation.
func (m *RbacPolicyMutation) URI() (r string, exists bool) {
	v := m.uri
	if v == nil {
		return
	}
	return *v, true
}

// OldURI returns the old "uri" field's value of the RbacPolicy entity.
// If the RbacPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacPolicyMutation) OldURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURI: %w", err)
	}
	return oldValue.URI, nil
}

// ClearURI clears the value of the "uri" field.
func (m *RbacPolicyMutation) ClearURI() {
	m.uri = nil
	m.clearedFields[rbacpolicy.FieldURI] = struct{}{}
}

// URICleared returns if the "uri" field was cleared in this mutation.
func (m *RbacPolicyMutation) URICleared() bool {
	_, ok := m.clearedFields[rbacpolicy.FieldURI]
	return ok
}

// ResetURI resets all changes to the "uri" field.
func (m *RbacPolicyMutation) ResetURI() {
	m.uri = nil
	delete(m.clearedFields, rbacpolicy.FieldURI)
}

// Where appends a list predicates to the RbacPolicyMutation builder.
func (m *RbacPolicyMutation) Where(ps ...predicate.RbacPolicy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RbacPolicyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RbacPolicyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RbacPolicy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RbacPolicyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RbacPolicyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RbacPolicy).
func (m *RbacPolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RbacPolicyMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, rbacpolicy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rbacpolicy.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, rbacpolicy.FieldUpdatedBy)
	}
	if m.created_by != nil {
		fields = append(fields, rbacpolicy.FieldCreatedBy)
	}
	if m.role != nil {
		fields = append(fields, rbacpolicy.FieldRole)
	}
	if m.obj != nil {
		fields = append(fields, rbacpolicy.FieldObj)
	}
	if m.act != nil {
		fields = append(fields, rbacpolicy.FieldAct)
	}
	if m.uri != nil {
		fields = append(fields, rbacpolicy.FieldURI)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RbacPolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rbacpolicy.FieldCreatedAt:
		return m.CreatedAt()
	case rbacpolicy.FieldUpdatedAt:
		return m.UpdatedAt()
	case rbacpolicy.FieldUpdatedBy:
		return m.UpdatedBy()
	case rbacpolicy.FieldCreatedBy:
		return m.CreatedBy()
	case rbacpolicy.FieldRole:
		return m.Role()
	case rbacpolicy.FieldObj:
		return m.Obj()
	case rbacpolicy.FieldAct:
		return m.Act()
	case rbacpolicy.FieldURI:
		return m.URI()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RbacPolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rbacpolicy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rbacpolicy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rbacpolicy.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case rbacpolicy.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case rbacpolicy.FieldRole:
		return m.OldRole(ctx)
	case rbacpolicy.FieldObj:
		return m.OldObj(ctx)
	case rbacpolicy.FieldAct:
		return m.OldAct(ctx)
	case rbacpolicy.FieldURI:
		return m.OldURI(ctx)
	}
	return nil, fmt.Errorf("unknown RbacPolicy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RbacPolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rbacpolicy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rbacpolicy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rbacpolicy.FieldUpdatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case rbacpolicy.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case rbacpolicy.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case rbacpolicy.FieldObj:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObj(v)
		return nil
	case rbacpolicy.FieldAct:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAct(v)
		return nil
	case rbacpolicy.FieldURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURI(v)
		return nil
	}
	return fmt.Errorf("unknown RbacPolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RbacPolicyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RbacPolicyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RbacPolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RbacPolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RbacPolicyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rbacpolicy.FieldRole) {
		fields = append(fields, rbacpolicy.FieldRole)
	}
	if m.FieldCleared(rbacpolicy.FieldObj) {
		fields = append(fields, rbacpolicy.FieldObj)
	}
	if m.FieldCleared(rbacpolicy.FieldAct) {
		fields = append(fields, rbacpolicy.FieldAct)
	}
	if m.FieldCleared(rbacpolicy.FieldURI) {
		fields = append(fields, rbacpolicy.FieldURI)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RbacPolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RbacPolicyMutation) ClearField(name string) error {
	switch name {
	case rbacpolicy.FieldRole:
		m.ClearRole()
		return nil
	case rbacpolicy.FieldObj:
		m.ClearObj()
		return nil
	case rbacpolicy.FieldAct:
		m.ClearAct()
		return nil
	case rbacpolicy.FieldURI:
		m.ClearURI()
		return nil
	}
	return fmt.Errorf("unknown RbacPolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RbacPolicyMutation) ResetField(name string) error {
	switch name {
	case rbacpolicy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rbacpolicy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rbacpolicy.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case rbacpolicy.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case rbacpolicy.FieldRole:
		m.ResetRole()
		return nil
	case rbacpolicy.FieldObj:
		m.ResetObj()
		return nil
	case rbacpolicy.FieldAct:
		m.ResetAct()
		return nil
	case rbacpolicy.FieldURI:
		m.ResetURI()
		return nil
	}
	return fmt.Errorf("unknown RbacPolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RbacPolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RbacPolicyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RbacPolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RbacPolicyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RbacPolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RbacPolicyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RbacPolicyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RbacPolicy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RbacPolicyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RbacPolicy edge %s", name)
}

// RbacRoleMutation represents an operation that mutates the RbacRole nodes in the graph.
type RbacRoleMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	updated_by    *uuid.UUID
	created_by    *uuid.UUID
	status        *bool
	name          *string
	description   *string
	clearedFields map[string]struct{}
	users         map[int64]struct{}
	removedusers  map[int64]struct{}
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*RbacRole, error)
	predicates    []predicate.RbacRole
}

var _ ent.Mutation = (*RbacRoleMutation)(nil)

// rbacroleOption allows management of the mutation configuration using functional options.
type rbacroleOption func(*RbacRoleMutation)

// newRbacRoleMutation creates new mutation for the RbacRole entity.
func newRbacRoleMutation(c config, op Op, opts ...rbacroleOption) *RbacRoleMutation {
	m := &RbacRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRbacRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRbacRoleID sets the ID field of the mutation.
func withRbacRoleID(id int64) rbacroleOption {
	return func(m *RbacRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *RbacRole
		)
		m.oldValue = func(ctx context.Context) (*RbacRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RbacRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRbacRole sets the old RbacRole of the mutation.
func withRbacRole(node *RbacRole) rbacroleOption {
	return func(m *RbacRoleMutation) {
		m.oldValue = func(context.Context) (*RbacRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RbacRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RbacRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RbacRole entities.
func (m *RbacRoleMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RbacRoleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RbacRoleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RbacRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RbacRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RbacRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RbacRole entity.
// If the RbacRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RbacRoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RbacRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RbacRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RbacRole entity.
// If the RbacRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RbacRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RbacRoleMutation) SetUpdatedBy(u uuid.UUID) {
	m.updated_by = &u
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RbacRoleMutation) UpdatedBy() (r uuid.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the RbacRole entity.
// If the RbacRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacRoleMutation) OldUpdatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RbacRoleMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RbacRoleMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RbacRoleMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the RbacRole entity.
// If the RbacRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacRoleMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RbacRoleMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetStatus sets the "status" field.
func (m *RbacRoleMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *RbacRoleMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RbacRole entity.
// If the RbacRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacRoleMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RbacRoleMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *RbacRoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RbacRoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the RbacRole entity.
// If the RbacRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacRoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RbacRoleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RbacRoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RbacRoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the RbacRole entity.
// If the RbacRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RbacRoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RbacRoleMutation) ResetDescription() {
	m.description = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RbacRoleMutation) AddUserIDs(ids ...int64) {
	if m.users == nil {
		m.users = make(map[int64]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RbacRoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RbacRoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RbacRoleMutation) RemoveUserIDs(ids ...int64) {
	if m.removedusers == nil {
		m.removedusers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RbacRoleMutation) RemovedUsersIDs() (ids []int64) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RbacRoleMutation) UsersIDs() (ids []int64) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RbacRoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the RbacRoleMutation builder.
func (m *RbacRoleMutation) Where(ps ...predicate.RbacRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RbacRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RbacRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RbacRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RbacRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RbacRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RbacRole).
func (m *RbacRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RbacRoleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, rbacrole.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rbacrole.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, rbacrole.FieldUpdatedBy)
	}
	if m.created_by != nil {
		fields = append(fields, rbacrole.FieldCreatedBy)
	}
	if m.status != nil {
		fields = append(fields, rbacrole.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, rbacrole.FieldName)
	}
	if m.description != nil {
		fields = append(fields, rbacrole.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RbacRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rbacrole.FieldCreatedAt:
		return m.CreatedAt()
	case rbacrole.FieldUpdatedAt:
		return m.UpdatedAt()
	case rbacrole.FieldUpdatedBy:
		return m.UpdatedBy()
	case rbacrole.FieldCreatedBy:
		return m.CreatedBy()
	case rbacrole.FieldStatus:
		return m.Status()
	case rbacrole.FieldName:
		return m.Name()
	case rbacrole.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RbacRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rbacrole.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rbacrole.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rbacrole.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case rbacrole.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case rbacrole.FieldStatus:
		return m.OldStatus(ctx)
	case rbacrole.FieldName:
		return m.OldName(ctx)
	case rbacrole.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown RbacRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RbacRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rbacrole.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rbacrole.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rbacrole.FieldUpdatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case rbacrole.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case rbacrole.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case rbacrole.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case rbacrole.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown RbacRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RbacRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RbacRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RbacRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RbacRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RbacRoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RbacRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RbacRoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RbacRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RbacRoleMutation) ResetField(name string) error {
	switch name {
	case rbacrole.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rbacrole.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rbacrole.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case rbacrole.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case rbacrole.FieldStatus:
		m.ResetStatus()
		return nil
	case rbacrole.FieldName:
		m.ResetName()
		return nil
	case rbacrole.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown RbacRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RbacRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, rbacrole.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RbacRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rbacrole.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RbacRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, rbacrole.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RbacRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rbacrole.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RbacRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, rbacrole.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RbacRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case rbacrole.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RbacRoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown RbacRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RbacRoleMutation) ResetEdge(name string) error {
	switch name {
	case rbacrole.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown RbacRole edge %s", name)
}

// SubtaskMutation represents an operation that mutates the Subtask nodes in the graph.
type SubtaskMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	created_at             *time.Time
	updated_at             *time.Time
	updated_by             *uuid.UUID
	created_by             *uuid.UUID
	status                 *bool
	detection_type         *int16
	adddetection_type      *int16
	params                 *map[string]interface{}
	src_ep_filter_strategy *map[string]interface{}
	src_ep_sel_strategy    *map[string]interface{}
	src_ep_sel_num         *int
	addsrc_ep_sel_num      *int
	dst_ep_filter_strategy *map[string]interface{}
	dst_ep_sel_strategy    *map[string]interface{}
	dst_ep_sel_num         *int
	adddst_ep_sel_num      *int
	clearedFields          map[string]struct{}
	task                   *uuid.UUID
	clearedtask            bool
	done                   bool
	oldValue               func(context.Context) (*Subtask, error)
	predicates             []predicate.Subtask
}

var _ ent.Mutation = (*SubtaskMutation)(nil)

// subtaskOption allows management of the mutation configuration using functional options.
type subtaskOption func(*SubtaskMutation)

// newSubtaskMutation creates new mutation for the Subtask entity.
func newSubtaskMutation(c config, op Op, opts ...subtaskOption) *SubtaskMutation {
	m := &SubtaskMutation{
		config:        c,
		op:            op,
		typ:           TypeSubtask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubtaskID sets the ID field of the mutation.
func withSubtaskID(id uuid.UUID) subtaskOption {
	return func(m *SubtaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Subtask
		)
		m.oldValue = func(ctx context.Context) (*Subtask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subtask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubtask sets the old Subtask of the mutation.
func withSubtask(node *Subtask) subtaskOption {
	return func(m *SubtaskMutation) {
		m.oldValue = func(context.Context) (*Subtask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubtaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubtaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Subtask entities.
func (m *SubtaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubtaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubtaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subtask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SubtaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubtaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Subtask entity.
// If the Subtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubtaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubtaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubtaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubtaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Subtask entity.
// If the Subtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubtaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubtaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SubtaskMutation) SetUpdatedBy(u uuid.UUID) {
	m.updated_by = &u
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SubtaskMutation) UpdatedBy() (r uuid.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Subtask entity.
// If the Subtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubtaskMutation) OldUpdatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SubtaskMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *SubtaskMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SubtaskMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Subtask entity.
// If the Subtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubtaskMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SubtaskMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetTaskID sets the "task_id" field.
func (m *SubtaskMutation) SetTaskID(u uuid.UUID) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *SubtaskMutation) TaskID() (r uuid.UUID, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the Subtask entity.
// If the Subtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubtaskMutation) OldTaskID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *SubtaskMutation) ResetTaskID() {
	m.task = nil
}

// SetStatus sets the "status" field.
func (m *SubtaskMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *SubtaskMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Subtask entity.
// If the Subtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubtaskMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SubtaskMutation) ResetStatus() {
	m.status = nil
}

// SetDetectionType sets the "detection_type" field.
func (m *SubtaskMutation) SetDetectionType(i int16) {
	m.detection_type = &i
	m.adddetection_type = nil
}

// DetectionType returns the value of the "detection_type" field in the mutation.
func (m *SubtaskMutation) DetectionType() (r int16, exists bool) {
	v := m.detection_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDetectionType returns the old "detection_type" field's value of the Subtask entity.
// If the Subtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubtaskMutation) OldDetectionType(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetectionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetectionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetectionType: %w", err)
	}
	return oldValue.DetectionType, nil
}

// AddDetectionType adds i to the "detection_type" field.
func (m *SubtaskMutation) AddDetectionType(i int16) {
	if m.adddetection_type != nil {
		*m.adddetection_type += i
	} else {
		m.adddetection_type = &i
	}
}

// AddedDetectionType returns the value that was added to the "detection_type" field in this mutation.
func (m *SubtaskMutation) AddedDetectionType() (r int16, exists bool) {
	v := m.adddetection_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetDetectionType resets all changes to the "detection_type" field.
func (m *SubtaskMutation) ResetDetectionType() {
	m.detection_type = nil
	m.adddetection_type = nil
}

// SetParams sets the "params" field.
func (m *SubtaskMutation) SetParams(value map[string]interface{}) {
	m.params = &value
}

// Params returns the value of the "params" field in the mutation.
func (m *SubtaskMutation) Params() (r map[string]interface{}, exists bool) {
	v := m.params
	if v == nil {
		return
	}
	return *v, true
}

// OldParams returns the old "params" field's value of the Subtask entity.
// If the Subtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubtaskMutation) OldParams(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParams is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParams: %w", err)
	}
	return oldValue.Params, nil
}

// ResetParams resets all changes to the "params" field.
func (m *SubtaskMutation) ResetParams() {
	m.params = nil
}

// SetSrcEpFilterStrategy sets the "src_ep_filter_strategy" field.
func (m *SubtaskMutation) SetSrcEpFilterStrategy(value map[string]interface{}) {
	m.src_ep_filter_strategy = &value
}

// SrcEpFilterStrategy returns the value of the "src_ep_filter_strategy" field in the mutation.
func (m *SubtaskMutation) SrcEpFilterStrategy() (r map[string]interface{}, exists bool) {
	v := m.src_ep_filter_strategy
	if v == nil {
		return
	}
	return *v, true
}

// OldSrcEpFilterStrategy returns the old "src_ep_filter_strategy" field's value of the Subtask entity.
// If the Subtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubtaskMutation) OldSrcEpFilterStrategy(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSrcEpFilterStrategy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSrcEpFilterStrategy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSrcEpFilterStrategy: %w", err)
	}
	return oldValue.SrcEpFilterStrategy, nil
}

// ResetSrcEpFilterStrategy resets all changes to the "src_ep_filter_strategy" field.
func (m *SubtaskMutation) ResetSrcEpFilterStrategy() {
	m.src_ep_filter_strategy = nil
}

// SetSrcEpSelStrategy sets the "src_ep_sel_strategy" field.
func (m *SubtaskMutation) SetSrcEpSelStrategy(value map[string]interface{}) {
	m.src_ep_sel_strategy = &value
}

// SrcEpSelStrategy returns the value of the "src_ep_sel_strategy" field in the mutation.
func (m *SubtaskMutation) SrcEpSelStrategy() (r map[string]interface{}, exists bool) {
	v := m.src_ep_sel_strategy
	if v == nil {
		return
	}
	return *v, true
}

// OldSrcEpSelStrategy returns the old "src_ep_sel_strategy" field's value of the Subtask entity.
// If the Subtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubtaskMutation) OldSrcEpSelStrategy(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSrcEpSelStrategy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSrcEpSelStrategy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSrcEpSelStrategy: %w", err)
	}
	return oldValue.SrcEpSelStrategy, nil
}

// ResetSrcEpSelStrategy resets all changes to the "src_ep_sel_strategy" field.
func (m *SubtaskMutation) ResetSrcEpSelStrategy() {
	m.src_ep_sel_strategy = nil
}

// SetSrcEpSelNum sets the "src_ep_sel_num" field.
func (m *SubtaskMutation) SetSrcEpSelNum(i int) {
	m.src_ep_sel_num = &i
	m.addsrc_ep_sel_num = nil
}

// SrcEpSelNum returns the value of the "src_ep_sel_num" field in the mutation.
func (m *SubtaskMutation) SrcEpSelNum() (r int, exists bool) {
	v := m.src_ep_sel_num
	if v == nil {
		return
	}
	return *v, true
}

// OldSrcEpSelNum returns the old "src_ep_sel_num" field's value of the Subtask entity.
// If the Subtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubtaskMutation) OldSrcEpSelNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSrcEpSelNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSrcEpSelNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSrcEpSelNum: %w", err)
	}
	return oldValue.SrcEpSelNum, nil
}

// AddSrcEpSelNum adds i to the "src_ep_sel_num" field.
func (m *SubtaskMutation) AddSrcEpSelNum(i int) {
	if m.addsrc_ep_sel_num != nil {
		*m.addsrc_ep_sel_num += i
	} else {
		m.addsrc_ep_sel_num = &i
	}
}

// AddedSrcEpSelNum returns the value that was added to the "src_ep_sel_num" field in this mutation.
func (m *SubtaskMutation) AddedSrcEpSelNum() (r int, exists bool) {
	v := m.addsrc_ep_sel_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetSrcEpSelNum resets all changes to the "src_ep_sel_num" field.
func (m *SubtaskMutation) ResetSrcEpSelNum() {
	m.src_ep_sel_num = nil
	m.addsrc_ep_sel_num = nil
}

// SetDstEpFilterStrategy sets the "dst_ep_filter_strategy" field.
func (m *SubtaskMutation) SetDstEpFilterStrategy(value map[string]interface{}) {
	m.dst_ep_filter_strategy = &value
}

// DstEpFilterStrategy returns the value of the "dst_ep_filter_strategy" field in the mutation.
func (m *SubtaskMutation) DstEpFilterStrategy() (r map[string]interface{}, exists bool) {
	v := m.dst_ep_filter_strategy
	if v == nil {
		return
	}
	return *v, true
}

// OldDstEpFilterStrategy returns the old "dst_ep_filter_strategy" field's value of the Subtask entity.
// If the Subtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubtaskMutation) OldDstEpFilterStrategy(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDstEpFilterStrategy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDstEpFilterStrategy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDstEpFilterStrategy: %w", err)
	}
	return oldValue.DstEpFilterStrategy, nil
}

// ResetDstEpFilterStrategy resets all changes to the "dst_ep_filter_strategy" field.
func (m *SubtaskMutation) ResetDstEpFilterStrategy() {
	m.dst_ep_filter_strategy = nil
}

// SetDstEpSelStrategy sets the "dst_ep_sel_strategy" field.
func (m *SubtaskMutation) SetDstEpSelStrategy(value map[string]interface{}) {
	m.dst_ep_sel_strategy = &value
}

// DstEpSelStrategy returns the value of the "dst_ep_sel_strategy" field in the mutation.
func (m *SubtaskMutation) DstEpSelStrategy() (r map[string]interface{}, exists bool) {
	v := m.dst_ep_sel_strategy
	if v == nil {
		return
	}
	return *v, true
}

// OldDstEpSelStrategy returns the old "dst_ep_sel_strategy" field's value of the Subtask entity.
// If the Subtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubtaskMutation) OldDstEpSelStrategy(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDstEpSelStrategy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDstEpSelStrategy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDstEpSelStrategy: %w", err)
	}
	return oldValue.DstEpSelStrategy, nil
}

// ResetDstEpSelStrategy resets all changes to the "dst_ep_sel_strategy" field.
func (m *SubtaskMutation) ResetDstEpSelStrategy() {
	m.dst_ep_sel_strategy = nil
}

// SetDstEpSelNum sets the "dst_ep_sel_num" field.
func (m *SubtaskMutation) SetDstEpSelNum(i int) {
	m.dst_ep_sel_num = &i
	m.adddst_ep_sel_num = nil
}

// DstEpSelNum returns the value of the "dst_ep_sel_num" field in the mutation.
func (m *SubtaskMutation) DstEpSelNum() (r int, exists bool) {
	v := m.dst_ep_sel_num
	if v == nil {
		return
	}
	return *v, true
}

// OldDstEpSelNum returns the old "dst_ep_sel_num" field's value of the Subtask entity.
// If the Subtask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubtaskMutation) OldDstEpSelNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDstEpSelNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDstEpSelNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDstEpSelNum: %w", err)
	}
	return oldValue.DstEpSelNum, nil
}

// AddDstEpSelNum adds i to the "dst_ep_sel_num" field.
func (m *SubtaskMutation) AddDstEpSelNum(i int) {
	if m.adddst_ep_sel_num != nil {
		*m.adddst_ep_sel_num += i
	} else {
		m.adddst_ep_sel_num = &i
	}
}

// AddedDstEpSelNum returns the value that was added to the "dst_ep_sel_num" field in this mutation.
func (m *SubtaskMutation) AddedDstEpSelNum() (r int, exists bool) {
	v := m.adddst_ep_sel_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetDstEpSelNum resets all changes to the "dst_ep_sel_num" field.
func (m *SubtaskMutation) ResetDstEpSelNum() {
	m.dst_ep_sel_num = nil
	m.adddst_ep_sel_num = nil
}

// ClearTask clears the "task" edge to the Task entity.
func (m *SubtaskMutation) ClearTask() {
	m.clearedtask = true
	m.clearedFields[subtask.FieldTaskID] = struct{}{}
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *SubtaskMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *SubtaskMutation) TaskIDs() (ids []uuid.UUID) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *SubtaskMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// Where appends a list predicates to the SubtaskMutation builder.
func (m *SubtaskMutation) Where(ps ...predicate.Subtask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubtaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubtaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subtask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubtaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubtaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subtask).
func (m *SubtaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubtaskMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, subtask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subtask.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, subtask.FieldUpdatedBy)
	}
	if m.created_by != nil {
		fields = append(fields, subtask.FieldCreatedBy)
	}
	if m.task != nil {
		fields = append(fields, subtask.FieldTaskID)
	}
	if m.status != nil {
		fields = append(fields, subtask.FieldStatus)
	}
	if m.detection_type != nil {
		fields = append(fields, subtask.FieldDetectionType)
	}
	if m.params != nil {
		fields = append(fields, subtask.FieldParams)
	}
	if m.src_ep_filter_strategy != nil {
		fields = append(fields, subtask.FieldSrcEpFilterStrategy)
	}
	if m.src_ep_sel_strategy != nil {
		fields = append(fields, subtask.FieldSrcEpSelStrategy)
	}
	if m.src_ep_sel_num != nil {
		fields = append(fields, subtask.FieldSrcEpSelNum)
	}
	if m.dst_ep_filter_strategy != nil {
		fields = append(fields, subtask.FieldDstEpFilterStrategy)
	}
	if m.dst_ep_sel_strategy != nil {
		fields = append(fields, subtask.FieldDstEpSelStrategy)
	}
	if m.dst_ep_sel_num != nil {
		fields = append(fields, subtask.FieldDstEpSelNum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubtaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subtask.FieldCreatedAt:
		return m.CreatedAt()
	case subtask.FieldUpdatedAt:
		return m.UpdatedAt()
	case subtask.FieldUpdatedBy:
		return m.UpdatedBy()
	case subtask.FieldCreatedBy:
		return m.CreatedBy()
	case subtask.FieldTaskID:
		return m.TaskID()
	case subtask.FieldStatus:
		return m.Status()
	case subtask.FieldDetectionType:
		return m.DetectionType()
	case subtask.FieldParams:
		return m.Params()
	case subtask.FieldSrcEpFilterStrategy:
		return m.SrcEpFilterStrategy()
	case subtask.FieldSrcEpSelStrategy:
		return m.SrcEpSelStrategy()
	case subtask.FieldSrcEpSelNum:
		return m.SrcEpSelNum()
	case subtask.FieldDstEpFilterStrategy:
		return m.DstEpFilterStrategy()
	case subtask.FieldDstEpSelStrategy:
		return m.DstEpSelStrategy()
	case subtask.FieldDstEpSelNum:
		return m.DstEpSelNum()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubtaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subtask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subtask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subtask.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case subtask.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case subtask.FieldTaskID:
		return m.OldTaskID(ctx)
	case subtask.FieldStatus:
		return m.OldStatus(ctx)
	case subtask.FieldDetectionType:
		return m.OldDetectionType(ctx)
	case subtask.FieldParams:
		return m.OldParams(ctx)
	case subtask.FieldSrcEpFilterStrategy:
		return m.OldSrcEpFilterStrategy(ctx)
	case subtask.FieldSrcEpSelStrategy:
		return m.OldSrcEpSelStrategy(ctx)
	case subtask.FieldSrcEpSelNum:
		return m.OldSrcEpSelNum(ctx)
	case subtask.FieldDstEpFilterStrategy:
		return m.OldDstEpFilterStrategy(ctx)
	case subtask.FieldDstEpSelStrategy:
		return m.OldDstEpSelStrategy(ctx)
	case subtask.FieldDstEpSelNum:
		return m.OldDstEpSelNum(ctx)
	}
	return nil, fmt.Errorf("unknown Subtask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubtaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subtask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subtask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subtask.FieldUpdatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case subtask.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case subtask.FieldTaskID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case subtask.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case subtask.FieldDetectionType:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetectionType(v)
		return nil
	case subtask.FieldParams:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParams(v)
		return nil
	case subtask.FieldSrcEpFilterStrategy:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSrcEpFilterStrategy(v)
		return nil
	case subtask.FieldSrcEpSelStrategy:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSrcEpSelStrategy(v)
		return nil
	case subtask.FieldSrcEpSelNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSrcEpSelNum(v)
		return nil
	case subtask.FieldDstEpFilterStrategy:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDstEpFilterStrategy(v)
		return nil
	case subtask.FieldDstEpSelStrategy:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDstEpSelStrategy(v)
		return nil
	case subtask.FieldDstEpSelNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDstEpSelNum(v)
		return nil
	}
	return fmt.Errorf("unknown Subtask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubtaskMutation) AddedFields() []string {
	var fields []string
	if m.adddetection_type != nil {
		fields = append(fields, subtask.FieldDetectionType)
	}
	if m.addsrc_ep_sel_num != nil {
		fields = append(fields, subtask.FieldSrcEpSelNum)
	}
	if m.adddst_ep_sel_num != nil {
		fields = append(fields, subtask.FieldDstEpSelNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubtaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subtask.FieldDetectionType:
		return m.AddedDetectionType()
	case subtask.FieldSrcEpSelNum:
		return m.AddedSrcEpSelNum()
	case subtask.FieldDstEpSelNum:
		return m.AddedDstEpSelNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubtaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subtask.FieldDetectionType:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDetectionType(v)
		return nil
	case subtask.FieldSrcEpSelNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSrcEpSelNum(v)
		return nil
	case subtask.FieldDstEpSelNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDstEpSelNum(v)
		return nil
	}
	return fmt.Errorf("unknown Subtask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubtaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubtaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubtaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Subtask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubtaskMutation) ResetField(name string) error {
	switch name {
	case subtask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subtask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subtask.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case subtask.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case subtask.FieldTaskID:
		m.ResetTaskID()
		return nil
	case subtask.FieldStatus:
		m.ResetStatus()
		return nil
	case subtask.FieldDetectionType:
		m.ResetDetectionType()
		return nil
	case subtask.FieldParams:
		m.ResetParams()
		return nil
	case subtask.FieldSrcEpFilterStrategy:
		m.ResetSrcEpFilterStrategy()
		return nil
	case subtask.FieldSrcEpSelStrategy:
		m.ResetSrcEpSelStrategy()
		return nil
	case subtask.FieldSrcEpSelNum:
		m.ResetSrcEpSelNum()
		return nil
	case subtask.FieldDstEpFilterStrategy:
		m.ResetDstEpFilterStrategy()
		return nil
	case subtask.FieldDstEpSelStrategy:
		m.ResetDstEpSelStrategy()
		return nil
	case subtask.FieldDstEpSelNum:
		m.ResetDstEpSelNum()
		return nil
	}
	return fmt.Errorf("unknown Subtask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubtaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.task != nil {
		edges = append(edges, subtask.EdgeTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubtaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subtask.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubtaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubtaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubtaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtask {
		edges = append(edges, subtask.EdgeTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubtaskMutation) EdgeCleared(name string) bool {
	switch name {
	case subtask.EdgeTask:
		return m.clearedtask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubtaskMutation) ClearEdge(name string) error {
	switch name {
	case subtask.EdgeTask:
		m.ClearTask()
		return nil
	}
	return fmt.Errorf("unknown Subtask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubtaskMutation) ResetEdge(name string) error {
	switch name {
	case subtask.EdgeTask:
		m.ResetTask()
		return nil
	}
	return fmt.Errorf("unknown Subtask edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	updated_by      *uuid.UUID
	created_by      *uuid.UUID
	status          *bool
	name            *string
	comment         *string
	clearedFields   map[string]struct{}
	subtasks        map[uuid.UUID]struct{}
	removedsubtasks map[uuid.UUID]struct{}
	clearedsubtasks bool
	done            bool
	oldValue        func(context.Context) (*Task, error)
	predicates      []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id uuid.UUID) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TaskMutation) SetUpdatedBy(u uuid.UUID) {
	m.updated_by = &u
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TaskMutation) UpdatedBy() (r uuid.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TaskMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TaskMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TaskMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TaskMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetStatus sets the "status" field.
func (m *TaskMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *TaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TaskMutation) ResetName() {
	m.name = nil
}

// SetComment sets the "comment" field.
func (m *TaskMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *TaskMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *TaskMutation) ResetComment() {
	m.comment = nil
}

// AddSubtaskIDs adds the "subtasks" edge to the Subtask entity by ids.
func (m *TaskMutation) AddSubtaskIDs(ids ...uuid.UUID) {
	if m.subtasks == nil {
		m.subtasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.subtasks[ids[i]] = struct{}{}
	}
}

// ClearSubtasks clears the "subtasks" edge to the Subtask entity.
func (m *TaskMutation) ClearSubtasks() {
	m.clearedsubtasks = true
}

// SubtasksCleared reports if the "subtasks" edge to the Subtask entity was cleared.
func (m *TaskMutation) SubtasksCleared() bool {
	return m.clearedsubtasks
}

// RemoveSubtaskIDs removes the "subtasks" edge to the Subtask entity by IDs.
func (m *TaskMutation) RemoveSubtaskIDs(ids ...uuid.UUID) {
	if m.removedsubtasks == nil {
		m.removedsubtasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.subtasks, ids[i])
		m.removedsubtasks[ids[i]] = struct{}{}
	}
}

// RemovedSubtasks returns the removed IDs of the "subtasks" edge to the Subtask entity.
func (m *TaskMutation) RemovedSubtasksIDs() (ids []uuid.UUID) {
	for id := range m.removedsubtasks {
		ids = append(ids, id)
	}
	return
}

// SubtasksIDs returns the "subtasks" edge IDs in the mutation.
func (m *TaskMutation) SubtasksIDs() (ids []uuid.UUID) {
	for id := range m.subtasks {
		ids = append(ids, id)
	}
	return
}

// ResetSubtasks resets all changes to the "subtasks" edge.
func (m *TaskMutation) ResetSubtasks() {
	m.subtasks = nil
	m.clearedsubtasks = false
	m.removedsubtasks = nil
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, task.FieldUpdatedBy)
	}
	if m.created_by != nil {
		fields = append(fields, task.FieldCreatedBy)
	}
	if m.status != nil {
		fields = append(fields, task.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, task.FieldName)
	}
	if m.comment != nil {
		fields = append(fields, task.FieldComment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldUpdatedAt:
		return m.UpdatedAt()
	case task.FieldUpdatedBy:
		return m.UpdatedBy()
	case task.FieldCreatedBy:
		return m.CreatedBy()
	case task.FieldStatus:
		return m.Status()
	case task.FieldName:
		return m.Name()
	case task.FieldComment:
		return m.Comment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case task.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case task.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case task.FieldStatus:
		return m.OldStatus(ctx)
	case task.FieldName:
		return m.OldName(ctx)
	case task.FieldComment:
		return m.OldComment(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case task.FieldUpdatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case task.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case task.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case task.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case task.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case task.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case task.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case task.FieldStatus:
		m.ResetStatus()
		return nil
	case task.FieldName:
		m.ResetName()
		return nil
	case task.FieldComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subtasks != nil {
		edges = append(edges, task.EdgeSubtasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeSubtasks:
		ids := make([]ent.Value, 0, len(m.subtasks))
		for id := range m.subtasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsubtasks != nil {
		edges = append(edges, task.EdgeSubtasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeSubtasks:
		ids := make([]ent.Value, 0, len(m.removedsubtasks))
		for id := range m.removedsubtasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubtasks {
		edges = append(edges, task.EdgeSubtasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeSubtasks:
		return m.clearedsubtasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeSubtasks:
		m.ResetSubtasks()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	updated_by    *uuid.UUID
	created_by    *uuid.UUID
	status        *bool
	name          *string
	remark        *string
	token         *string
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Token, error)
	predicates    []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id int64) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TokenMutation) SetUpdatedBy(u uuid.UUID) {
	m.updated_by = &u
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TokenMutation) UpdatedBy() (r uuid.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUpdatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TokenMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TokenMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TokenMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TokenMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUserID sets the "user_id" field.
func (m *TokenMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TokenMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TokenMutation) ResetUserID() {
	m.user = nil
}

// SetStatus sets the "status" field.
func (m *TokenMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *TokenMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TokenMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *TokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TokenMutation) ResetName() {
	m.name = nil
}

// SetRemark sets the "remark" field.
func (m *TokenMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *TokenMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *TokenMutation) ResetRemark() {
	m.remark = nil
}

// SetToken sets the "token" field.
func (m *TokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *TokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *TokenMutation) ResetToken() {
	m.token = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *TokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[token.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, token.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, token.FieldUpdatedBy)
	}
	if m.created_by != nil {
		fields = append(fields, token.FieldCreatedBy)
	}
	if m.user != nil {
		fields = append(fields, token.FieldUserID)
	}
	if m.status != nil {
		fields = append(fields, token.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, token.FieldName)
	}
	if m.remark != nil {
		fields = append(fields, token.FieldRemark)
	}
	if m.token != nil {
		fields = append(fields, token.FieldToken)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldCreatedAt:
		return m.CreatedAt()
	case token.FieldUpdatedAt:
		return m.UpdatedAt()
	case token.FieldUpdatedBy:
		return m.UpdatedBy()
	case token.FieldCreatedBy:
		return m.CreatedBy()
	case token.FieldUserID:
		return m.UserID()
	case token.FieldStatus:
		return m.Status()
	case token.FieldName:
		return m.Name()
	case token.FieldRemark:
		return m.Remark()
	case token.FieldToken:
		return m.Token()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case token.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case token.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case token.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case token.FieldUserID:
		return m.OldUserID(ctx)
	case token.FieldStatus:
		return m.OldStatus(ctx)
	case token.FieldName:
		return m.OldName(ctx)
	case token.FieldRemark:
		return m.OldRemark(ctx)
	case token.FieldToken:
		return m.OldToken(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case token.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case token.FieldUpdatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case token.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case token.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case token.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case token.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case token.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case token.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case token.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case token.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case token.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case token.FieldUserID:
		m.ResetUserID()
		return nil
	case token.FieldStatus:
		m.ResetStatus()
		return nil
	case token.FieldName:
		m.ResetName()
		return nil
	case token.FieldRemark:
		m.ResetRemark()
		return nil
	case token.FieldToken:
		m.ResetToken()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, token.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, token.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	created_at    *time.Time
	updated_at    *time.Time
	updated_by    *uuid.UUID
	created_by    *uuid.UUID
	status        *bool
	username      *string
	email         *string
	clearedFields map[string]struct{}
	roles         map[int64]struct{}
	removedroles  map[int64]struct{}
	clearedroles  bool
	tokens        map[int64]struct{}
	removedtokens map[int64]struct{}
	clearedtokens bool
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserMutation) SetUpdatedBy(u uuid.UUID) {
	m.updated_by = &u
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserMutation) UpdatedBy() (r uuid.UUID, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *UserMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// AddRoleIDs adds the "roles" edge to the RbacRole entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...int64) {
	if m.roles == nil {
		m.roles = make(map[int64]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the RbacRole entity.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the RbacRole entity was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the RbacRole entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...int64) {
	if m.removedroles == nil {
		m.removedroles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the RbacRole entity.
func (m *UserMutation) RemovedRolesIDs() (ids []int64) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []int64) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddTokenIDs adds the "tokens" edge to the Token entity by ids.
func (m *UserMutation) AddTokenIDs(ids ...int64) {
	if m.tokens == nil {
		m.tokens = make(map[int64]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the Token entity.
func (m *UserMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the Token entity was cleared.
func (m *UserMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the Token entity by IDs.
func (m *UserMutation) RemoveTokenIDs(ids ...int64) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the Token entity.
func (m *UserMutation) RemovedTokensIDs() (ids []int64) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *UserMutation) TokensIDs() (ids []int64) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *UserMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.created_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldUpdatedBy:
		return m.UpdatedBy()
	case user.FieldCreatedBy:
		return m.CreatedBy()
	case user.FieldStatus:
		return m.Status()
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case user.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case user.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case user.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.tokens != nil {
		edges = append(edges, user.EdgeTokens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.removedtokens != nil {
		edges = append(edges, user.EdgeTokens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	if m.clearedtokens {
		edges = append(edges, user.EdgeTokens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRoles:
		return m.clearedroles
	case user.EdgeTokens:
		return m.clearedtokens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	case user.EdgeTokens:
		m.ResetTokens()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
